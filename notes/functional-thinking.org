#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:t |:t
#+TITLE: Functional Thinking 读书笔记
#+DATE: <2016-01-07 Thu>
#+AUTHOR: Sean Wang
#+EMAIL: shanguren@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.2)

* Why
- 不能用使用斧子的方法使用电锯。学习一个全新的编程模式与学习一门新的编程语言是两
  回事。
- Computer science often advances in fits and starts. (断断续续地；间歇地)
- 好的想法往往在很多年后才会变成主流。
  + Simula67 创建于 1967 年，是第一门面向对象编程语言，但面向对象在 1983 年 C++出现并
    逐渐流行之后才变得主流。
- 函数式编程几十年前被学术界开发出来，现在正慢慢地蔓延（crept into）到各个现代编
  程语言中。

#+name: Example 1-1. Word frequencies in Java
#+BEGIN_SRC java
  public class Words {
      private Set<String> NON_WORDS = new HashSet<String>() {{
              add("the"); add("and"); add("of"); add("to"); add("a");
              add("i"); add("it"); add("in"); add("or"); add("is");
              add("d"); add("s"); add("as"); add("so"); add("but");
              add("be");
          }};

      public Map wordFreq(String words) {
          TreeMap<String, Integer> wordMap = new TreeMap<String, Integer>();
          Matcher m = Pattern.compile("\\w+").matcher(words);
          while (m.find()) {
              String word = m.group().toLowerCase();
              if (!NON_WORDS.contains(word)) {
                  if (wordMap.get(word) == null) {
                      wordMap.put(word, 1);
                  }
                  else {
                      wordMap.put(word, wordMap.get(word) + 1);
                  }
              }
          }
          return wordMap;
      }
  }
#+END_SRC

#+name: Example 1-2. Word frequency in Java 8
#+BEGIN_SRC java
  private List<String> regexToList(String words, String regex) {
      List wordList = new ArrayList<>();
      Matcher m = Pattern.compile(regex).matcher(words);
      while (m.find())
          wordList.add(m.group());
      return wordList;
  }

  public Map wordFreq(String words) {
      TreeMap<String, Integer> wordMap = new TreeMap<>();
      regexToList(words, "\\w+").stream()
          .map(w -> w.toLowerCase())
          .filter(w -> !NON_WORDS.contains(w))
          .forEach(w -> wordMap.put(w, wordMap.getOrDefault(w, 0)+1));
      return wordMap;
  }
#+END_SRC

** 编程语言趋势
- Groovy 添加了很多函数式编程功能，包括 =memoization= 等高级特性。
- Java 增加了 lambda blocks (i.e., higher-order functions)
- JavaScript 具有很多函数式编程特性
- C++ 在 2011 标准中添加了 lambda blocks

** Ceding Control to the Language/Runtime

** Concision
#+BEGIN_QUOTE
OO makes code understandable by encapsulating moving parts. FP makes code
understandable by minimizing moving parts.
-- Michael Feathers
#+END_QUOTE

** Three versions of indexOfAny()
#+name: Example 1-3. indexOfAny() from Apache Commons StringUtils
#+BEGIN_SRC java
  // From Apache Commons Lang, http://commons.apache.org/lang/
  public static int indexOfAny(String str, char[] searchChars) {
      if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {
          return INDEX_NOT_FOUND;
      }
      int csLen = str.length();
      int csLast = csLen - 1;
      int searchLen = searchChars.length;
      int searchLast = searchLen - 1;

      for (int i = 0; i < csLen; i++) {
          char ch = str.charAt(i);
          for (int j = 0; j < searchLen; j++) {
              if (searchChars[j] == ch) {
                  if (i < csLast && j < searchLast && CharUtils.isHighSurrogate(ch)) {
                      if (searchChars[j+1] == str.charAt(i+1)) {
                          return i;
                      }
                  } else {
                      return i;
                  }
              }
          }
      }
      return INDEX_NOT_FOUND;
  }
#+END_SRC

#+name: Example 1-5. Scala version of firstIndexOfAny()
#+BEGIN_SRC java
  def firstIndexOfAny(input : String, searchChars : Seq[Char]) : Option[Int] = {
      def indexedInput = (0 until input.length).zip(input)
      val result = for (pair <- indexedInput;
                        char <- searchChars;
                        if (char == pair._2))
          yield(pair._1)
      if (result.isEmpty)
          None
      else
          Some(result.head)
#+END_SRC
