#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:t |:t
#+TITLE: 《C 语言核心技术》读书笔记
#+DATE: <2016-01-07 Thu>
#+AUTHOR: Sean Wang
#+EMAIL: sean@think.sean.org
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 8.3.2)

* 类型转换
** 隐式类型转换何时发生
- 操作数类型不合适
- 调用一个函数时，自变量的类型与函数参数类型不匹配
- 变量初始化或给变量赋值

#+BEGIN_SRC c
int sum  = 22, count = 5;
double mean = (double)sum / count;
#+END_SRC

由于类型转换运算符的优先级高于除法运算符，因此 =sum= 先被转换为 =double= 。然后
编译器隐式地将除数 =count= 转型，然后进行除法。
*** Conversion rank
- 两个无符号整数类型具有不同的转换等级，位长较宽类型的等级较高。
- 
* 表达式和运算符
* 函数
* 数组
* 指针
* 结构、联合、位字段
* 声明
* 动态内存管理
** 用于动态内存管理的函数
- malloc() :: 分配新的内存区域
- calloc() :: 分配新的内存区域
- realloc() :: 调整以前分配的内存区域
- free() :: 释放以前分配的内存区域
** 注意事项
- =malloc()= 分配的内存不保证会被初始化
- =calloc()= 会将分配的内存的每个字节初始化为 0
- =malloc()= 和 =calloc()= 都返回 =void= 指针
- 当存取分配的内存位置时，所使用的指针类型决定了如何翻译该位置的数据。
- 如果内存分配成功，会得到“指向内存区域开端”的指针。“开端”指的是内存区域的最
  低字节地址。
- *NOTE* 分配的内存区域会被 *对齐* ，任何对象类型都可以存储在该地址。
- 如果给 =malloc()= 传入的参数为 0，则行为取决于 =malloc()= 的具体实现，可能返回
  =NULL= ，也可能返回一个 unique pointer， 返回的这个指针可以传给 =free()= 函数。
- 如果给 =free()= 传入的参数为 =NULL= ，则函数不起任何作用。
- 如果给 =free()= 传入的指针不是 =malloc()= 等函数分配的，或者已经被释放掉，则
  =free()= 的行为未定义。

#+BEGIN_SRC c
  char *getline(unsigned int len_max) {
    char *linePtr = malloc(len_max + 1);
    if (linePtr != NULL) {
      int c = EOF;
      unsigned int i = 0;
      while (i < len_max && (c = getchar()) != '\n' && c != EOF) {
        linePtr[i++] = (char) c;
      }
      linePtr[i] = '\0';

      if (c == EOF && i == 0) {
        free(linePtr);
        linePtr = NULL;
      } else {
        linePtr = realloc(linePtr, i+1);
      }
    }
    return linePtr;
  }

  char *line;
  if ((line = getline(128)) != NULL)
    {
      /* */
      free(line);
    }
#+END_SRC

* 输入和输出
* 预处理
